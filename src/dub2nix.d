#!/usr/bin/env dub
/+ dub.sdl:
    name "dub2nix"
    stringImportPaths "."
    dependency "vibe-d:data" version="*"
+/
import vibe.data.json, std.string;

struct DubSelections {
    int fileVersion;
    string[string] versions;
}

struct DubRepo {
    string owner;
    string kind;
    string project;
}

/// Query Dub registry for the repository information of a package
auto findRepo(string pname) @trusted {
    const url = "http://code.dlang.org/packages/" ~ pname ~ ".json";
version(none) {
    // This works, but causes "leaking eventcore driver" warnings at shutdown
    import vibe.http.client : requestHTTP;
    scope res = requestHTTP();
    const json = res.readJson();
} else {
    import std.net.curl: get;
    // parseJsonString takes immutable string, so need the .idup here
    const json = parseJsonString(get(url).idup);
}
    return deserializeJson!DubRepo(json["repository"]);
}

struct NixPrefetchGit {
    string url;                     /// URL of GIT repository
    string rev;                     /// sha1 or tag
    string sha256;                  /// calculated by from nix-prefetch-git
    @optional bool fetchSubmodules; /// optional; defaults to true
    @optional string date;          /// ignored; fetchgit doesn't actually want this
    @optional string type;          /// "git", like Go deps.nix
}

/// Invoke nix-prefetch-git and return the parsed JSON
auto nixPrefetchGit(string url, string rev) @safe {
    import std.process : executeShell;
    return deserializeJson!NixPrefetchGit(
        executeShell("nix-prefetch-git --fetch-submodules --quiet " ~ url ~ " " ~ rev).output
    );
}

struct DubDep {
    NixPrefetchGit fetch;           /// like Go deps.nix
}

/// Fetch the repo information for package `key` and version `value`
auto prefetch(Tuple)(in Tuple pair) @safe {
    const repo = findRepo(pair.key);
    assert(repo.kind == "github");
    const url = "https://" ~ repo.kind ~ ".com/" ~ repo.owner ~ '/' ~ repo.project ~ ".git";
    const tag = "v" ~ pair.value;
    auto set = nixPrefetchGit(url, tag);
    // Overwrite the sha1 ref with the tag instead, so we have the version info as well
    set.rev = tag;
    set.type = "git";
    return DubDep(set);
}

/// Convert D string to Nix string literal
auto toNixString(in string s) pure @safe {
    if (s is null) {
        return "null";
    } else if (s.indexOfAny("\"\n") >= 0)
        return "''\n" ~ s ~ "''";
    else
        return '"' ~ s ~ '"';
}

unittest {
    static assert(toNixString(null) == "null");
    static assert(toNixString("hello") == `"hello"`);
    static assert(toNixString("with\nnewline") == "''\nwith\nnewline''");
    static assert(toNixString(`with "quotes"`) == "''\nwith \"quotes\"''");
}

/// Convert D bool to Nix boolean literal
auto toNixString(bool b) pure @safe {
    return b ? "true" : "false";
}

unittest {
    static assert(toNixString(true) == "true");
    static assert(toNixString(false) == "false");
}

/// Convert D struct to Nix set
auto toNixString(T)(in T pod) pure @safe if (is(T == struct)) {
    string set = "{\n";
    foreach(i, ref key; pod.tupleof) {
        const id = __traits(identifier, pod.tupleof[i]);
        set ~= id ~ " = " ~ toNixString(key) ~ ";\n";
    }
    return set ~ "}";
}

unittest {
    struct TestStruct { bool b; }
    static assert(toNixString(TestStruct.init) == "{\nb = false;\n}");
}

/// Convert D AArray to Nix set
auto toNixString(T)(in T[string] aa) pure @safe {
    string set = "{\n";
    foreach(id, ref key; aa) {
        set ~= id ~ " = " ~ toNixString(key) ~ ";\n";
    }
    return set ~ "}";
}

unittest {
    static assert(toNixString(["s": "x"]) == "{\ns = \"x\";\n}");
}

/// Convert D array to Nix list
import std.range : isForwardRange;
auto toNixString(R)(in R range) pure @safe if (isForwardRange!R && !is(R : string)) {
    string list = "[ ";
    foreach(const ref item; range) {
        list ~= toNixString(item) ~ " ";
    }
    return list ~ "]";
}

unittest {
    static assert(toNixString(["a"]) == `[ "a" ]`);
}

// enum Selections = deserializeJson!DubSelections(import("./dub.selections.json"));
// static assert(Selections.fileVersion == 1);

void main(string[] args) {
    import std.stdio : writeln;
    import std.parallelism : taskPool;
    import std.array : byPair, array;
    import std.file : readText, write;

    string filename = args.length == 2 ? args[1] : "./dub.selections.json";
    const selections = deserializeJson!DubSelections(readText(filename));
    assert(selections.fileVersion == 1);

    const nix = "# This file was generated by dub2nix v0.1.0\n"
        ~ toNixString(taskPool.amap!prefetch(selections.versions.byPair.array));

    if (args.length == 3) {
        write(args[2], nix.representation);
    } else {
        writeln(nix);
    }
}
