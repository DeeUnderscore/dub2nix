#!/usr/bin/env dub
/+ dub.sdl:
    name "dub2nix"
    stringImportPaths "."
    dependency "vibe-d:data" version="*"
    dependency "vibe-d:http" version="*"
+/
import vibe.data.json, std.string;

struct DubSelections {
    int fileVersion;
    string[string] versions;
}

struct DubRepo {
    string owner;
    string kind;
    string project;
}

/// Query Dub registry for the repository information of a package
auto findRepo(string pname) @safe {
    import vibe.http.client : requestHTTP;
    scope res = requestHTTP("http://code.dlang.org/packages/" ~ pname ~ ".json");
    auto json = res.readJson();
    return deserializeJson!DubRepo(json["repository"]);
}

struct NixPrefetchGit {
    @optional string type; // like Go
    string url;
    string rev;
    string date; // fetchgit doesn't actually want this
    string sha256;
    bool fetchSubmodules;
}

/// Invoke nix-prefetch-git and return the parsed JSON
auto nixPrefetchGit(string url, string rev) {
    import std.process : executeShell;
    return deserializeJson!NixPrefetchGit(
        executeShell("nix-prefetch-git --fetch-submodules --quiet " ~ url ~ " " ~ rev).output
    );
}

struct DubDep {
    NixPrefetchGit fetch;
}

auto prefetch(T)(in T kv) {
    auto repo = findRepo(kv.key);
    assert(repo.kind == "github");
    auto url = "https://" ~ repo.kind ~ ".com/" ~ repo.owner ~ '/' ~ repo.project ~ ".git";
    auto tag = "v" ~ kv.value;
    auto set = nixPrefetchGit(url, tag);
    // Overwrite the sha1 ref with the tag instead, so we have the version info as well
    set.rev = tag;
    set.type = "git";
    return DubDep(set);
}

/// Convert D string to Nix string literal
auto toNixString(in string s) pure {
    if (s is null) {
        return "null";
    } else if (s.indexOfAny("\"\n") >= 0)
        return "''\n" ~ s ~ "''";
    else
        return '"' ~ s ~ '"';
}

unittest {
    static assert(toNixString(null) == "null");
    static assert(toNixString("hello") == `"hello"`);
    static assert(toNixString("with\nnewline") == "''\nwith\nnewline''");
    static assert(toNixString(`with "quotes"`) == "''\nwith \"quotes\"''");
}

/// Convert D bool to Nix boolean literal
auto toNixString(bool b) pure {
    return b ? "true" : "false";
}

unittest {
    static assert(toNixString(true) == "true");
    static assert(toNixString(false) == "false");
}

/// Convert D struct to Nix set
auto toNixString(T)(in T pod) pure if (is(T == struct)) {
    string set = "{\n";
    foreach(i, ref key; pod.tupleof) {
        auto id = __traits(identifier, pod.tupleof[i]);
        set ~= id ~ " = " ~ toNixString(key) ~ ";\n";
    }
    return set ~ "}";
}

unittest {
    struct TestStruct { bool b; }
    static assert(toNixString(TestStruct.init) == "{\nb = false;\n}");
}

/// Convert D AArray to Nix set
auto toNixString(T)(in T[string] aa) pure {
    string set = "{\n";
    foreach(id, ref key; aa) {
        set ~= id ~ " = " ~ toNixString(key) ~ ";\n";
    }
    return set ~ "}";
}

unittest {
    static assert(toNixString(["s": "x"]) == "{\ns = \"x\";\n}");
}

/// Convert D array to Nix list
import std.range : isForwardRange;
auto toNixString(R)(in R range) pure if (isForwardRange!R && !is(R : string)) {
    string list = "[ ";
    foreach(const ref item; range) {
        list ~= toNixString(item) ~ " ";
    }
    return list ~ "]";
}

unittest {
    static assert(toNixString(["a"]) == `[ "a" ]`);
}

// enum Selections = deserializeJson!DubSelections(import("./dub.selections.json"));
// static assert(Selections.fileVersion == 1);

void main(string[] args) {
    import std.stdio : writeln;
    import std.parallelism : taskPool;
    import std.array : byPair, array;
    import std.file : readText;
    import vibe.core.core: exitEventLoop;

    string filename = args.length == 2 ? args[1] : "./dub.selections.json";
    auto selections = deserializeJson!DubSelections(readText(filename));
    assert(selections.fileVersion == 1);

    writeln("# This file was generated by dub2nix v0.1.0");
    writeln(toNixString(taskPool.amap!prefetch(selections.versions.byPair.array)));
    exitEventLoop(true);
}
